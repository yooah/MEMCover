#!/usr/bin/env python

########################################################################
# Read permutation files generated by run_permute_cover.py in bulk
# (files to read specified by pstart, pnum)
# compute ranks for permutation test for given pairs in efile
#
# python run_ptest.py pstart pnum ptype -ef efile --pv (optional)
#
# e.g., to read 10 permutation file of type "tr" starting from index 0
#  and compute ranks for all gene pairs given in human_net.net
#
# >> python run_ptest.py 0 10 tr -ef human_net.net
#
# the resulting rank file will be stored as
# $ptype_$efile(without extension)_me_rank_$pstart_$pnum.txt
# in config.permute_dir directory
# e.g., the above command generates a file named "tr_human_net_me_rank_0_10.txt"
#
# use --pv option to compute pvalues and logp files
# (e.g., "tr_human_net_me_pv_0_10.txt" and "tr_human_net_me_logp_0_10.txt")
#
# edit INPUT/OUTPUT FILES as well as config.py file to change options.
#
########################################################################

import os
import argparse
import pandas
import logging
import numpy as np

from mut_ex import mut_ex
from utils import io, misc
import config
from config import cancers

# read arguments
parser = argparse.ArgumentParser()
parser.add_argument("pstart", help="starting file id", type=int)
parser.add_argument("pnum", help="number of files", type=int)
parser.add_argument("ptype", help="permutation type (tr or to)", type=str)
parser.add_argument("-ef", "--efile", help="edge list file name", type=str)
parser.add_argument("--pv", help="compute pvalue?)", action='store_true')

args = parser.parse_args()
pstart, pnum = args.pstart, args.pnum

if args.efile is None:
    efile = config.hn_file  # use default
else:
    efile = config.data_dir + args.efile

logging.info("use permutation files %d-%d for test.. " % (pstart, pnum-1))

# filename prefix
prefix = args.ptype + "_"
logging.info("%s permutation types ..." % args.ptype)

# INPUT FILES
mut_file = config.mut_file
pfile_prefix = config.permute_dir+prefix+"permuted_cover_"  # permutation file prefix
efile_prefix = config.me_dir + prefix + efile.split("/")[-1].split(".")[0]+"_"  # pair results prefix

# OUTPUT FILES
rank_file = efile_prefix+"me_rank_"+str(pstart)+"_"+str(pnum)+".txt"
pvfile = efile_prefix+"me_pv_"+str(pstart)+"_"+str(pnum)+".txt"
logpfile = efile_prefix+"me_logp_"+str(pstart)+"_"+str(pnum)+".txt"

# read graph
logging.info("reading %s... " % efile)
G = io.read_net(efile)
edges = G.edges()

# original cover (written in matrix format)
(genes, samples, rel_dic) = io.read_mut_matrix(mut_file)
# gene -> covered sample indices
original_gene_dic = dict([(x, misc.get_positives(rel_dic[x])) for x in rel_dic])
cover_size_list = mut_ex.comp_pair_cover(original_gene_dic, edges)
# ranks of original cover
rank_list = [0 for i in range(len(edges))]
norm_rank_list = [0 for i in range(len(edges))]

# for TR
if args.ptype == "tr":
    # construct dictionary each cancer type mapped to a set of sample indices
    sample_type_dic = io.read_dic(config.subtype_file)
    type_idx_dic = {}
    for cancer in cancers:
        type_idx_dic[cancer] = list(filter(lambda i: sample_type_dic[samples[i]] == cancer, range(len(samples))))
    type_coefs = dict([(cancer, config.nsamples/float(len(type_idx_dic[cancer]))) for cancer in cancers])
    logging.debug("cancer type normalizing coefficients: %s\n" % str(type_coefs))
    # cancer type -> gene ->  covered sample indices
    original_gene_dic_per_type = mut_ex.comp_type_dic(original_gene_dic, type_idx_dic)
    # normalizing coefficients for each cancer type
    cover_size_list_per_type = {}
    for cancer in cancers:
        cover_size_list_per_type[cancer] = \
            mut_ex.comp_pair_cover(original_gene_dic_per_type[cancer], edges)
    norm_cover_size_list = mut_ex.norm_cover_size(cover_size_list_per_type, type_coefs)
    # ranks for each type
    rank_list_per_type = {}
    for can in cancers:
        rank_list_per_type[can] = [0 for i in range(len(edges))]

# process each permutation file
for i in range(pstart, pstart+pnum):
    # read a permuted instance
    pfile = pfile_prefix+str(i)+".txt"
    if not os.path.isfile(pfile):
        logging.warning("%s doesn't exist" % pfile)
        continue
    logging.debug("reading %d-th permutation file", i)
    permuted_gene_dic = io.read_mut_list(pfile)
    # compute the cover sizes for given edges
    permuted_cover_size_list = mut_ex.comp_pair_cover(permuted_gene_dic, edges)
    # update rank each time to avoid store all permuted mutation instances
    rank_list = mut_ex.update_rank(rank_list, cover_size_list, permuted_cover_size_list)
    # for each type ONLY FOR tr/ts
    if args.ptype == "tr":
        # TS ranks
        permuted_gene_dic_per_type = mut_ex.comp_type_dic(permuted_gene_dic, type_idx_dic)
        permuted_cover_size_list_per_type = {}
        for can in cancers:
            permuted_cover_size_list_per_type[can] = mut_ex.comp_pair_cover(permuted_gene_dic_per_type[can], edges)
            rank_list_per_type[can] = mut_ex.update_rank(
                rank_list_per_type[can], cover_size_list_per_type[can], permuted_cover_size_list_per_type[can])
        # normalized TR ranks
        norm_permuted_cover_size_list = mut_ex.norm_cover_size(permuted_cover_size_list_per_type, type_coefs)
        norm_rank_list = mut_ex.update_rank(norm_rank_list, norm_cover_size_list, norm_permuted_cover_size_list)


# create ME data
rank_labels = ["gene1", "gene2", "raw_me_rank"]
d = zip(*edges) + [rank_list]
if args.ptype == "tr":
    rank_labels += ["norm_me_rank"]
    d += [norm_rank_list]
    rank_labels += [can+"_me_rank" for can in cancers]
    d += [rank_list_per_type[can] for can in cancers]

# Write the results
all_ranks = pandas.DataFrame(data=zip(*d), columns=rank_labels)
all_ranks.to_csv(rank_file, sep="\t", index=False)

if args.pv:
    pvs = mut_ex.comp_pv(all_ranks, args.ptype, pnum, cancers)
    pvs.to_csv(pvfile, sep="\t", index=False)
    logps = mut_ex.comp_logp(pvs, args.ptype, cancers)
    logps.to_csv(logpfile, sep="\t", index=False)
